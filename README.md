# Sorting-Methods

Abstract

This investigation explores the effectiveness of different sorting algorithms when sorting differently-sized sets of data, specifically the execution time of the algorithm. To conduct this investigation, seven different sorting algorithms were coded: Insertion, Selection, Bubble, Shell, Merge, Heap, and Quick. The algorithms were first tested using primitive integer values, each with sets of a thousand, ten thousand, and a hundred thousand integers. Afterwards, an Employee class was created to test out how each sorting algorithm would fare when sorting out objects. The Employee class was sorted by three attributes-age, salary, and name. Age was an integer value, salary was a float value, while name was a String object value. A thousand, ten thousand, and a hundred thousand objects were sorted by these three attributes. The O (N^2) algorithms (Insertion, Selection, Bubble) and the O (N*log (N)) (Shell, Merge, Heap, Quick) sorted the thousand element sets at a similar pace. However, the O (N^2) sorting time grew exponentially larger when sorting the ten thousand element sets and the hundred thousand element sets while the sorting times for the O (N*log (N)) algorithms did not increase significantly. Therefore, O (N^2) algorithms are only suited for sorting small sets of data while O (N*log (N)) can sort much larger sets of data. It was also found that sorting Strings takes around double the time it takes to sort integers/floats for all the sorting methods. Therefore, the type of data affects sorting speed but the efficiency of the sorting methods does not change with different types of data, because the sorting time of all the algorithms increased by the same ratio when comparing the sort times of integers/floats to Strings. 
